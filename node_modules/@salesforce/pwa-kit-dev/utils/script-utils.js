"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.readCredentials = exports.parseLog = exports.glob = exports.getProjectPkg = exports.getPkgJSON = exports.getCredentialsFile = exports.defaultMessage = exports.createBundle = exports.DEFAULT_DOCS_URL = exports.DEFAULT_CLOUD_ORIGIN = exports.CloudAPIClient = void 0;
var _os = _interopRequireDefault(require("os"));
var _path = _interopRequireDefault(require("path"));
var _archiver = _interopRequireDefault(require("archiver"));
var _nodeFetch = _interopRequireDefault(require("node-fetch"));
var _url = require("url");
var _promises = require("fs/promises");
var _fs = require("fs");
var _fsExtra = require("fs-extra");
var _minimatch = require("minimatch");
var _gitRevSync = _interopRequireDefault(require("git-rev-sync"));
var _validator = _interopRequireDefault(require("validator"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } /*
                                                                                                                                                                                                                                                                                                                                                                                                       * Copyright (c) 2022, Salesforce, Inc.
                                                                                                                                                                                                                                                                                                                                                                                                       * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                       * SPDX-License-Identifier: BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                                                                       * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                                                                       */
const DEFAULT_CLOUD_ORIGIN = 'https://cloud.mobify.com';
exports.DEFAULT_CLOUD_ORIGIN = DEFAULT_CLOUD_ORIGIN;
const DEFAULT_DOCS_URL = 'https://developer.salesforce.com/docs/commerce/pwa-kit-managed-runtime/guide/pushing-and-deploying-bundles.html';
exports.DEFAULT_DOCS_URL = DEFAULT_DOCS_URL;
/**
 * Get the package info for pwa-kit-dev.
 */
const getPkgJSON = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator(function* () {
    const candidates = [_path.default.join(__dirname, '..', 'package.json'), _path.default.join(__dirname, '..', '..', 'package.json')];
    for (const candidate of candidates) {
      try {
        const data = yield (0, _fsExtra.readJson)(candidate);
        return data;
      } catch {
        // Keep looking
      }
    }
    return {
      name: '@salesforce/pwa-kit-dev',
      version: 'unknown'
    };
  });
  return function getPkgJSON() {
    return _ref.apply(this, arguments);
  };
}();

/**
 * Get the package info for the current project.
 */
exports.getPkgJSON = getPkgJSON;
const getProjectPkg = /*#__PURE__*/function () {
  var _ref2 = _asyncToGenerator(function* () {
    const p = _path.default.join(process.cwd(), 'package.json');
    try {
      const data = yield (0, _fsExtra.readJson)(p);
      return data;
    } catch {
      throw new Error(`Could not read project package at "${p}"`);
    }
  });
  return function getProjectPkg() {
    return _ref2.apply(this, arguments);
  };
}();
exports.getProjectPkg = getProjectPkg;
class CloudAPIClient {
  constructor(params) {
    this.opts = {
      origin: params.origin || DEFAULT_CLOUD_ORIGIN,
      fetch: params.fetch || _nodeFetch.default,
      credentials: params.credentials
    };
  }
  getAuthHeader() {
    const {
      username,
      api_key
    } = this.opts.credentials;
    const encoded = Buffer.from(`${username}:${api_key}`, 'binary').toString('base64');
    return {
      Authorization: `Basic ${encoded}`
    };
  }
  getHeaders() {
    var _this = this;
    return _asyncToGenerator(function* () {
      const pkg = yield getPkgJSON();
      return _objectSpread({
        'User-Agent': `${pkg.name}@${pkg.version}`
      }, _this.getAuthHeader());
    })();
  }
  throwForStatus(res) {
    return _asyncToGenerator(function* () {
      if (res.status < 400) {
        return;
      }
      const body = yield res.text();
      let error;
      try {
        error = JSON.parse(body);
      } catch {
        error = {}; // Cloud doesn't always return JSON
      }

      if (res.status === 403) {
        error.docs_url = 'https://developer.salesforce.com/docs/commerce/pwa-kit-managed-runtime/guide/mrt-overview.html#users,-abilities,-and-roles';
      }
      throw new Error([`HTTP ${res.status}`, error.message || body, `For more information visit ${error.docs_url || DEFAULT_DOCS_URL}`].join('\n'));
    })();
  }
  push(bundle, projectSlug, target) {
    var _this2 = this;
    return _asyncToGenerator(function* () {
      const base = `api/projects/${projectSlug}/builds/`;
      const pathname = target ? base + `${target}/` : base;
      const url = new _url.URL(_this2.opts.origin);
      url.pathname = pathname;
      const body = Buffer.from(JSON.stringify(bundle));
      const headers = _objectSpread(_objectSpread({}, yield _this2.getHeaders()), {}, {
        'Content-Length': body.length.toString()
      });
      const res = yield _this2.opts.fetch(url.toString(), {
        body,
        method: 'POST',
        headers
      });
      yield _this2.throwForStatus(res);
      return yield res.json();
    })();
  }
  createLoggingToken(project, environment) {
    var _this3 = this;
    return _asyncToGenerator(function* () {
      const url = new _url.URL(_this3.opts.origin);
      url.pathname = `/api/projects/${project}/target/${environment}/jwt/`;
      const headers = _objectSpread(_objectSpread({}, yield _this3.getHeaders()), {}, {
        // Annoyingly, the new logging endpoint only accepts an
        // Authorization header that is inconsistent with our older APIs!
        Authorization: `Bearer ${_this3.opts.credentials.api_key}`
      });
      const res = yield _this3.opts.fetch(url.toString(), {
        method: 'POST',
        headers
      });
      yield _this3.throwForStatus(res);
      const data = yield res.json();
      return data['token'];
    })();
  }
}
exports.CloudAPIClient = CloudAPIClient;
const defaultMessage = (gitInstance = _gitRevSync.default) => {
  try {
    return `${gitInstance.branch()}: ${gitInstance.short()}`;
  } catch (err) {
    if ((err === null || err === void 0 ? void 0 : err.code) === 'ENOENT') {
      console.log('Using default bundle message as no message was provided and not in a Git repo.');
    }
    return 'PWA Kit Bundle';
  }
};
exports.defaultMessage = defaultMessage;
const createBundle = /*#__PURE__*/function () {
  var _ref3 = _asyncToGenerator(function* ({
    message,
    ssr_parameters,
    ssr_only,
    ssr_shared,
    buildDirectory,
    projectSlug
  }) {
    message = message || defaultMessage();
    const tmpDir = yield (0, _promises.mkdtemp)(_path.default.join(_os.default.tmpdir(), 'pwa-kit-dev-'));
    const destination = _path.default.join(tmpDir, 'build.tar');
    const filesInArchive = [];
    if (ssr_only.length === 0 || ssr_shared.length === 0) {
      throw new Error('no ssrOnly or ssrShared files are defined');
    }
    return Promise.resolve().then(() => (0, _promises.stat)(buildDirectory)).catch(() => {
      const fullPath = _path.default.join(process.cwd(), buildDirectory);
      throw new Error(`Build directory at path "${fullPath}" not found.\n` + 'Run `pwa-kit-dev build` first!');
    }).then(() => new Promise((resolve, reject) => {
      const output = (0, _fs.createWriteStream)(destination);
      const archive = (0, _archiver.default)('tar');
      archive.pipe(output);

      // See https://web.archive.org/web/20160712064705/http://archiverjs.com/docs/global.html#TarEntryData
      const newRoot = _path.default.join(projectSlug, 'bld', '');
      // WARNING: There are a lot of type assertions here because we use a very old
      // version of archiver, and the types provided don't match the docs. :\
      archive.directory(buildDirectory, '', entry => {
        const stats = entry.stats;
        if (stats !== null && stats !== void 0 && stats.isFile() && entry.name) {
          filesInArchive.push(entry.name);
        }
        entry.prefix = newRoot;
        return entry;
      });
      archive.on('error', reject);
      output.on('finish', resolve);
      archive.finalize();
    })).then(() => (0, _promises.readFile)(destination)).then(data => {
      const encoding = 'base64';
      return {
        message,
        encoding,
        data: data.toString(encoding),
        ssr_parameters,
        ssr_only: filesInArchive.filter(glob(ssr_only)),
        ssr_shared: filesInArchive.filter(glob(ssr_shared))
      };
    })
    // This is a false positive. The promise returned by `.finally()` won't resolve until
    // the `rm()` completes!
    // eslint-disable-next-line @typescript-eslint/no-misused-promises
    .finally(() => (0, _promises.rm)(tmpDir, {
      recursive: true
    }));
  });
  return function createBundle(_x) {
    return _ref3.apply(this, arguments);
  };
}();
exports.createBundle = createBundle;
const glob = patterns => {
  // The patterns can include negations, so matching is done against all
  // the patterns. A match is true if a given path matches any pattern and
  // does not match any negating patterns.

  const allPatterns = (patterns || []).map(pattern => new _minimatch.Minimatch(pattern, {
    nocomment: true
  })).filter(pattern => !pattern.empty);
  const positivePatterns = allPatterns.filter(pattern => !pattern.negate);
  const negativePatterns = allPatterns.filter(pattern => pattern.negate);
  return path => {
    if (path) {
      const positive = positivePatterns.some(pattern => pattern.match(path));
      const negative = negativePatterns.some(pattern => !pattern.match(path));
      return positive && !negative;
    }
    return false;
  };
};
exports.glob = glob;
const getCredentialsFile = (cloudOrigin, credentialsFile) => {
  if (credentialsFile) {
    return credentialsFile;
  } else {
    const url = new _url.URL(cloudOrigin);
    const host = url.host;
    const suffix = host === 'cloud.mobify.com' ? '' : `--${host}`;
    return _path.default.join(_os.default.homedir(), `.mobify${suffix}`);
  }
};
exports.getCredentialsFile = getCredentialsFile;
const readCredentials = /*#__PURE__*/function () {
  var _ref4 = _asyncToGenerator(function* (filepath) {
    try {
      const data = yield (0, _fsExtra.readJson)(filepath);
      return {
        username: data.username,
        api_key: data.api_key
      };
    } catch (e) {
      throw new Error(`Credentials file "${filepath}" not found.\n` + 'Visit https://runtime.commercecloud.com/account/settings for ' + 'steps on authorizing your computer to push bundles.');
    }
  });
  return function readCredentials(_x2) {
    return _ref4.apply(this, arguments);
  };
}();
exports.readCredentials = readCredentials;
const parseLog = log => {
  const parts = log.trim().split('\t');
  let requestId, shortRequestId, level;
  if (parts.length >= 3 && _validator.default.isISO8601(parts[0]) && _validator.default.isUUID(parts[1]) && _validator.default.isAlpha(parts[2])) {
    // An application log
    parts.shift();
    requestId = parts.shift();
    level = parts.shift();
  } else {
    // A platform log
    const words = parts[0].split(' ');
    level = words.shift();
    parts[0] = words.join(' ');
  }
  const message = parts.join('\t');
  const match = /(?<id>[a-f\d]{8})/.exec(requestId || message);
  if (match) {
    var _match$groups;
    shortRequestId = (_match$groups = match.groups) === null || _match$groups === void 0 ? void 0 : _match$groups.id;
  }
  return {
    level,
    message,
    shortRequestId
  };
};
exports.parseLog = parseLog;
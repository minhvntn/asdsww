"use strict";

var _fsExtra = require("fs-extra");
var _path = _interopRequireDefault(require("path"));
var _os = _interopRequireDefault(require("os"));
var scriptUtils = _interopRequireWildcard(require("./script-utils"));
function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function (nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== "object" && typeof obj !== "function") { return { default: obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }
function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }
function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return typeof key === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (typeof input !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (typeof res !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }
function _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; } /*
                                                                                                                                                                                                                                                                                                                                                                                                       * Copyright (c) 2021, salesforce.com, inc.
                                                                                                                                                                                                                                                                                                                                                                                                       * All rights reserved.
                                                                                                                                                                                                                                                                                                                                                                                                       * SPDX-License-Identifier: BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                                                                       * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/BSD-3-Clause
                                                                                                                                                                                                                                                                                                                                                                                                       */
const pkg = (0, _fsExtra.readJsonSync)(_path.default.join(__dirname, '../package.json'));
describe('scriptUtils', () => {
  const originalEnv = process.env;
  let tmpDir;
  beforeEach( /*#__PURE__*/_asyncToGenerator(function* () {
    process.env = _objectSpread({}, originalEnv);
    tmpDir = yield (0, _fsExtra.mkdtemp)(_path.default.join(_os.default.tmpdir(), 'scriptUtils-tests'));
  }));
  afterEach( /*#__PURE__*/_asyncToGenerator(function* () {
    process.env = originalEnv;
    tmpDir && (yield (0, _fsExtra.rm)(tmpDir, {
      recursive: true
    }));
  }));
  test('glob() with no patterns matches nothing', () => {
    const matcher = scriptUtils.glob();
    expect(matcher('')).toBe(false);
    expect(matcher('a.js')).toBe(false);
    expect(matcher()).toBe(false);
  });
  describe('glob() filters correctly', () => {
    const patterns = ['ssr.js', '**/*.jpg', '!**/no.jpg', 'abc.{js,jsx}'];
    const matcher = scriptUtils.glob(patterns);

    // Paths we expect to match
    const expectToMatch = ['ssr.js', 'test1.jpg', 'static/test2.jpg', 'static/assets/test3.jpg', 'abc.js', 'abc.jsx'];
    expectToMatch.forEach(path => test(`Expect path "${path}" to match`, () => {
      expect(matcher(path)).toBe(true);
    }));

    // Paths we expect not to match
    const expectNotToMatch = ['ssrxjs', 'subdirectory/ssr.js', 'no.jpg', 'static/no.jpg', 'abc.jsz'];
    expectNotToMatch.forEach(path => test(`Expect path "${path}" to NOT match`, () => {
      expect(matcher(path)).toBe(false);
    }));
    const allPaths = expectToMatch.concat(expectNotToMatch);
    test('glob works with Array.filter', () => {
      const matched = allPaths.filter(matcher);
      expect(matched).toHaveLength(expectToMatch.length);
    });
  });
  describe('CloudAPIClient', () => {
    const username = 'user123';
    const api_key = '123';
    const encoded = Buffer.from(`${username}:${api_key}`, 'binary').toString('base64');
    const expectedAuthHeader = {
      Authorization: `Basic ${encoded}`
    };
    test('getAuthHeader', /*#__PURE__*/_asyncToGenerator(function* () {
      const client = new scriptUtils.CloudAPIClient({
        credentials: {
          username,
          api_key
        }
      });
      expect(client.getAuthHeader()).toEqual(expectedAuthHeader);
    }));
    test('getHeaders', /*#__PURE__*/_asyncToGenerator(function* () {
      const client = new scriptUtils.CloudAPIClient({
        credentials: {
          username,
          api_key
        }
      });
      expect(yield client.getHeaders()).toEqual(_objectSpread({
        'User-Agent': `${pkg.name}@${pkg.version}`
      }, expectedAuthHeader));
    }));
  });
  test('getPkgJSON', /*#__PURE__*/_asyncToGenerator(function* () {
    const pkg = yield scriptUtils.getPkgJSON();
    expect(pkg.name).toBe('@salesforce/pwa-kit-dev');
  }));
  describe('defaultMessage', () => {
    test('works', /*#__PURE__*/_asyncToGenerator(function* () {
      const mockGit = {
        branch: () => 'branch',
        short: () => 'short'
      };
      expect(scriptUtils.defaultMessage(mockGit)).toBe('branch: short');
    }));
    test('works outside of a git repo', /*#__PURE__*/_asyncToGenerator(function* () {
      const mockGit = {
        branch: () => {
          throw {
            code: 'ENOENT'
          };
        },
        short: () => 'short'
      };
      expect(scriptUtils.defaultMessage(mockGit)).toBe('PWA Kit Bundle');
    }));
    test('works with any other error', /*#__PURE__*/_asyncToGenerator(function* () {
      const mockGit = {
        branch: () => {
          throw new Error();
        },
        short: () => 'short'
      };
      expect(scriptUtils.defaultMessage(mockGit)).toBe('PWA Kit Bundle');
    }));
  });
  test('getCredentialsFile', /*#__PURE__*/_asyncToGenerator(function* () {
    expect(scriptUtils.getCredentialsFile('https://example.com', '/path/to/.mobify')).toBe('/path/to/.mobify');
    expect(scriptUtils.getCredentialsFile('https://example.com', undefined)).toBe(_path.default.join(_os.default.homedir(), '.mobify--example.com'));
    expect(scriptUtils.getCredentialsFile('https://cloud.mobify.com', undefined)).toBe(_path.default.join(_os.default.homedir(), '.mobify'));
  }));
  describe('readCredentials', () => {
    test('should work', /*#__PURE__*/_asyncToGenerator(function* () {
      const creds = {
        username: 'alice',
        api_key: 'xyz'
      };
      const thePath = _path.default.join(tmpDir, '.mobify.test');
      yield (0, _fsExtra.writeFile)(thePath, JSON.stringify(creds), 'utf8');
      expect(yield scriptUtils.readCredentials(thePath)).toEqual(creds);
    }));
    test('should throw', /*#__PURE__*/_asyncToGenerator(function* () {
      const thePath = _path.default.join(tmpDir, '.mobify.test');
      yield expect( /*#__PURE__*/_asyncToGenerator(function* () {
        return yield scriptUtils.readCredentials(thePath);
      })).rejects.toThrow(Error);
    }));
  });
  describe('createBundle', () => {
    test('should throw if ssr_only and ssr_shared is empty', /*#__PURE__*/_asyncToGenerator(function* () {
      yield expect( /*#__PURE__*/_asyncToGenerator(function* () {
        return yield scriptUtils.createBundle({
          message: null,
          ssr_parameters: {},
          ssr_only: [],
          ssr_shared: [],
          buildDirectory: tmpDir,
          projectSlug: 'slug'
        });
      })).rejects.toThrow('no ssrOnly or ssrShared files are defined');
    }));
    test('should throw buildDir does not exist', /*#__PURE__*/_asyncToGenerator(function* () {
      yield expect( /*#__PURE__*/_asyncToGenerator(function* () {
        return yield scriptUtils.createBundle({
          message: null,
          ssr_parameters: {},
          ssr_only: ['*.js'],
          ssr_shared: ['*.js'],
          buildDirectory: _path.default.join(tmpDir, 'does-not-exist'),
          projectSlug: 'slug'
        });
      })).rejects.toThrow('Build directory at path');
    }));
    test('should archive a bundle', /*#__PURE__*/_asyncToGenerator(function* () {
      const message = 'message';
      const bundle = yield scriptUtils.createBundle({
        message,
        ssr_parameters: {},
        ssr_only: ['*.js'],
        ssr_shared: ['**/*.*'],
        buildDirectory: _path.default.join(__dirname, 'test-fixtures', 'minimal-built-app'),
        projectSlug: 'slug'
      });
      expect(bundle.message).toEqual(message);
      expect(bundle.encoding).toBe('base64');
      expect(bundle.ssr_parameters).toEqual({});
      expect(bundle.ssr_only).toEqual(['ssr.js']);
      expect(bundle.ssr_shared).toEqual(['ssr.js', 'static/favicon.ico']);

      // De-code and re-encode gives the same result, to show that it *is* b64 encoded
      expect(Buffer.from(bundle.data, 'base64').toString('base64')).toEqual(bundle.data);
    }));
  });
  describe('pushBundle', () => {
    test.each([[{
      projectSlug: 'project-slug',
      targetSlug: undefined,
      expectedURL: 'https://cloud.mobify.com/api/projects/project-slug/builds/',
      status: 200
    }], [{
      projectSlug: 'project-slug',
      targetSlug: 'target-slug',
      expectedURL: 'https://cloud.mobify.com/api/projects/project-slug/builds/target-slug/',
      status: 200
    }], [{
      projectSlug: 'project-slug',
      targetSlug: undefined,
      expectedURL: 'https://cloud.mobify.com/api/projects/project-slug/builds/',
      status: 401
    }]])('should push a built bundle and handle status codes (%p)', /*#__PURE__*/function () {
      var _ref18 = _asyncToGenerator(function* ({
        projectSlug,
        targetSlug,
        expectedURL,
        status
      }) {
        const message = 'message';
        const bundle = yield scriptUtils.createBundle({
          message,
          ssr_parameters: {},
          ssr_only: ['*.js'],
          ssr_shared: ['**/*.*'],
          buildDirectory: _path.default.join(__dirname, 'test-fixtures', 'minimal-built-app'),
          projectSlug
        });
        const username = 'user123';
        const api_key = '123';
        const credentials = {
          username,
          api_key
        };
        const goodResponseBody = {
          anything: 'anything'
        };

        // Older APIs on Cloud return JSON for good responses and text for errors,
        // hence the strange looking mock response setup.
        const text = () => status === 200 ? Promise.resolve(JSON.stringify(goodResponseBody)) : Promise.resolve('An error occurred');
        const json = () => status === 200 ? Promise.resolve(goodResponseBody) : Promise.reject();
        const responseMock = {
          status,
          text,
          json
        };
        const fetchMock = jest.fn( /*#__PURE__*/_asyncToGenerator(function* () {
          return responseMock;
        }));
        const client = new scriptUtils.CloudAPIClient({
          credentials,
          fetch: fetchMock
        });
        const fn = /*#__PURE__*/function () {
          var _ref20 = _asyncToGenerator(function* () {
            return yield client.push(bundle, projectSlug, targetSlug);
          });
          return function fn() {
            return _ref20.apply(this, arguments);
          };
        }();

        // TODO: Split up this batch of tests to avoid conditional assertions
        if (status === 200) {
          // eslint-disable-next-line jest/no-conditional-expect
          expect(yield fn()).toBe(goodResponseBody);
        } else {
          // eslint-disable-next-line jest/no-conditional-expect
          yield expect(fn).rejects.toThrow('For more information visit');
        }
        expect(fetchMock).toHaveBeenCalledTimes(1);
        expect(fetchMock).toHaveBeenCalledWith(expectedURL, expect.objectContaining({
          body: expect.anything(Buffer),
          method: 'POST',
          headers: {
            Authorization: expect.stringMatching(/^Basic /),
            'Content-Length': expect.stringMatching(/^\d+$/),
            'User-Agent': `${pkg.name}@${pkg.version}`
          }
        }));
      });
      return function (_x) {
        return _ref18.apply(this, arguments);
      };
    }());
  });
});
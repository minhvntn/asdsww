"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.load = void 0;
const assert_1 = require("assert");
const typedoc_1 = require("typedoc");
let hasMonkeyPatched = false;
function load(app) {
    if (hasMonkeyPatched) {
        throw new Error("typedoc-plugin-missing-exports cannot be loaded multiple times");
    }
    hasMonkeyPatched = true;
    let activeReflection;
    const referencedSymbols = new Map();
    const symbolToActiveRefl = new Map();
    const knownPrograms = new Map();
    function discoverMissingExports(context, program) {
        // An export is missing if if was referenced
        // Is not contained in the documented
        // And is "owned" by the active reflection
        const referenced = referencedSymbols.get(program) || new Set();
        const ownedByOther = new Set();
        referencedSymbols.set(program, ownedByOther);
        for (const s of [...referenced]) {
            if (context.project.getReflectionFromSymbol(s)) {
                referenced.delete(s);
            }
            else if (symbolToActiveRefl.get(s) !== activeReflection) {
                referenced.delete(s);
                ownedByOther.add(s);
            }
        }
        return referenced;
    }
    // Monkey patch the constructor for references so that we can get every
    const origCreateSymbolReference = typedoc_1.ReferenceType.createSymbolReference;
    typedoc_1.ReferenceType.createSymbolReference = function (symbol, context, name) {
        (0, assert_1.ok)(activeReflection, "active reflection has not been set");
        const set = referencedSymbols.get(context.program);
        symbolToActiveRefl.set(symbol, activeReflection);
        if (set) {
            set.add(symbol);
        }
        else {
            referencedSymbols.set(context.program, new Set([symbol]));
        }
        return origCreateSymbolReference.call(this, symbol, context, name);
    };
    app.options.addDeclaration({
        name: "internalModule",
        help: "Define the name of the module that internal symbols which are not exported should be placed into.",
        defaultValue: "<internal>",
    });
    app.converter.on(typedoc_1.Converter.EVENT_CREATE_DECLARATION, (context, refl) => {
        if (refl.kindOf(typedoc_1.ReflectionKind.Project | typedoc_1.ReflectionKind.Module)) {
            knownPrograms.set(refl, context.program);
            activeReflection = refl;
        }
    });
    app.converter.on(typedoc_1.Converter.EVENT_RESOLVE_BEGIN, function onResolveBegin(context) {
        const modules = context.project.getChildrenByKind(typedoc_1.ReflectionKind.Module);
        if (modules.length === 0) {
            // Single entry point, just target the project.
            modules.push(context.project);
        }
        for (const mod of modules) {
            activeReflection = mod;
            const program = knownPrograms.get(mod);
            if (!program)
                continue;
            let missing = discoverMissingExports(context, program);
            if (!missing || !missing.size)
                continue;
            // Nasty hack here that will almost certainly break in future TypeDoc versions.
            context.setActiveProgram(program);
            const internalNs = context
                .withScope(mod)
                .createDeclarationReflection(typedoc_1.ReflectionKind.Module, void 0, void 0, context.converter.application.options.getValue("internalModule"));
            context.finalizeDeclarationReflection(internalNs);
            const internalContext = context.withScope(internalNs);
            // Keep track of which symbols we've tried to convert. If they don't get converted
            // when calling convertSymbol, then the user has excluded them somehow, don't go into
            // an infinite loop when converting.
            const tried = new Set();
            do {
                for (const s of missing) {
                    if (shouldConvertSymbol(s, context.checker)) {
                        internalContext.converter.convertSymbol(internalContext, s);
                    }
                    tried.add(s);
                }
                missing = discoverMissingExports(context, program);
                for (const s of tried) {
                    missing.delete(s);
                }
            } while (missing.size > 0);
            // All the missing symbols were excluded, so get rid of our namespace.
            if (!internalNs.children?.length) {
                context.project.removeReflection(internalNs);
            }
            context.setActiveProgram(void 0);
        }
        knownPrograms.clear();
        referencedSymbols.clear();
    }, void 0, 1e9);
}
exports.load = load;
function shouldConvertSymbol(symbol, checker) {
    while (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Alias) {
        symbol = checker.getAliasedSymbol(symbol);
    }
    // We're looking at an unknown symbol which is declared in some package without
    // type declarations. We know nothing about it, so don't convert it.
    if (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Transient) {
        return false;
    }
    // This is something inside the special Node `Globals` interface. Don't convert it
    // because TypeDoc will reasonably assert that "Property" means that a symbol should be
    // inside something that can have properties.
    if (symbol.flags & typedoc_1.TypeScript.SymbolFlags.Property && symbol.name !== "default") {
        return false;
    }
    return true;
}
//# sourceMappingURL=index.js.map